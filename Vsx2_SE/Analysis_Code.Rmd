---
title: "VSX2_Analysis"
author:
  name: "Cody Ramirez"
  email: cody.ramirez@stjude.org
  affiliation: St. Jude Children's Research Hospital, Memphis, TN
date: "8/16/2021"
output: html_document
---


```{r}
#Loadds in important libraries for downstream analysis
library(Seurat)
library(Matrix)
library(ggplot2)
library(future)
library(sctransform)
library(leiden)
library(harmony)
library(Rcpp)
library(rliger)
library(cowplot)
library(patchwork)
library(SeuratWrappers)
library(dittoSeq)
library(stringr)
library(knitr)

# For consistency in tSNE/UMAP.
set.seed(1234)
# Sets the future settings for multicore processing
plan(strategy = "multiprocess", workers = 50)#Changing the current plan to access parallelization
options(parallelly.fork.enable = TRUE, future.globals.maxSize = +Inf, future.seed = TRUE) #enables forking in Rstudio (potentially unstable)
plan()

# Pull standard cell cycle genes for cell cycle scoring
# Had to change genes to title case for mice genes (Human genes are annotated in all CAPS)
s.genes <- str_to_title(cc.genes.updated.2019$s.genes)
g2m.genes <- str_to_title(cc.genes.updated.2019$g2m.genes)

# Identifies all samples in directory based on folder names
samples <- list.dirs(paste(full_path, "/CellRangerCount", sep = ""), recursive = F)

# Reads QC spreadsheet (columns are 'Sample', 'lower', 'upper', and 'mito')
qc_cutoff <- read.csv(paste(full_path, "/scRNAseq_QC_cutoff.tsv", sep = ""), sep = '\t', header = TRUE)


sample.name <- vector()
Seurat.obj <- list()


# For loops through all scRNA-Seq samples
for (i in 1:length(samples)){
  
  # Reads in CellRanger aligned data
  Seurat.data <- Read10X(data.dir = paste(full_path, "/CellRangerCount/", sample.name[i], "/outs/filtered_feature_bc_matrix", sep = ""))

  # Creates a Seurat Object, only includes genes expressed in at least 3 cells and includes cells where at least 200 genes were detected
  Seurat.obj[[i]] <- CreateSeuratObject(counts = Seurat.data, min.cells = 3, min.features = 200)

  # Adds sample name to metadata
  Seurat.obj[[i]]$Sample <- sample.name[i]

  # Calculate the percentage of reads that map to the mitochondrial genome
  Seurat.obj[[i]] <- PercentageFeatureSet(Seurat.obj[[i]], pattern = "^mt-", col.name = "percent.mito")
  
  # Visualize QC metric data before filtering is conducted
  VlnPlot(object = Seurat.obj[[i]], features = c("nCount_RNA", "nFeature_RNA", "percent.mito"), pt.size = 0, ncol = 3)
  FeatureScatter(object = Seurat.obj[[i]], feature1 = "nCount_RNA", feature2 = "percent.mito") + ggplot2::geom_hline(yintercept = qc_cutoff$mito[i])
  FeatureScatter(object = Seurat.obj[[i]], feature1 = "nCount_RNA", feature2 = "nFeature_RNA") + ggplot2::geom_hline(yintercept = qc_cutoff$lower[i]) + ggplot2::geom_hline(yintercept = qc_cutoff$upper[i])

  # Filtering cells by # of genes and mitochondrial content, specific filtering parameters can be found in scRNAseq_QC_cutoff.tsv
  ############################################################################################################
  Seurat.obj[[i]] <- subset(x = Seurat.obj[[i]], subset = nFeature_RNA < qc_cutoff$upper[i] & nFeature_RNA > qc_cutoff$lower[i] & percent.mito < qc_cutoff$mito[i])
  ############################################################################################################
  
  # Visualize QC metric data after filtering is conducted
  VlnPlot(object = Seurat.obj[[i]], features = c("nCount_RNA", "nFeature_RNA", "percent.mito"), pt.size = 0, ncol = 3)
  FeatureScatter(object = Seurat.obj[[i]], feature1 = "nCount_RNA", feature2 = "percent.mito") + ggplot2::geom_hline(yintercept = qc_cutoff$mito[i])
  FeatureScatter(object = Seurat.obj[[i]], feature1 = "nCount_RNA", feature2 = "nFeature_RNA") + ggplot2::geom_hline(yintercept = qc_cutoff$lower[i]) + ggplot2::geom_hline(yintercept = qc_cutoff$upper[i])

}
rm(qc_cutoff, Seurat.data)
```





```{r}
Single.Sample <- function(Seurat.obj)
{
  Seurat.obj <- NormalizeData(Seurat.obj)
  Seurat.obj <- CellCycleScoring(Seurat.obj, s.features = s.genes, g2m.features = g2m.genes)
  Seurat.obj <- FindVariableFeatures(Seurat.obj, selection.method = "vst", nfeatures = 3000)
  Seurat.obj <- ScaleData(Seurat.obj)
  Seurat.obj <- RunPCA(Seurat.obj, verbose = FALSE)
  Seurat.obj <- RunUMAP(Seurat.obj, dims = 1:30)
  Seurat.obj <- FindNeighbors(Seurat.obj, dims = 1:30)
  Seurat.obj <- FindClusters(Seurat.obj, resolution = 0.4, algorithm = 4)
  
  return(Seurat.obj)
}


Simple.Merge <- function(Seurat.list)
{

  Seurat.list <- lapply(X = Seurat.list, FUN = function(x) {
  x <- NormalizeData(x)
  x <- CellCycleScoring(x, s.features = s.genes, g2m.features = g2m.genes)
  })
  
  Seurat.combined <- merge(Seurat.list[[1]], Seurat.list[c(-1)])
  Seurat.combined <- FindVariableFeatures(Seurat.combined, selection.method = "vst", nfeatures = 3000)
  Seurat.combined <- ScaleData(Seurat.combined)
  Seurat.combined <- RunPCA(Seurat.combined, verbose = FALSE)
  Seurat.combined <- RunUMAP(Seurat.combined, dims = 1:30)
  Seurat.combined <- FindNeighbors(Seurat.combined, dims = 1:30)
  Seurat.combined <- FindClusters(Seurat.combined, resolution = 0.4, algorithm = 4)

  return(Seurat.combined)
}


Seurat.Integration <- function(Seurat.list)
{

  Seurat.list <- lapply(X = Seurat.list, FUN = function(x) {
  x <- SCTransform(x, variable.features.n = 3000, verbose = TRUE, return.only.var.genes = FALSE)
  x <- CellCycleScoring(x, s.features = s.genes, g2m.features = g2m.genes)
  })
  
  features <- SelectIntegrationFeatures(object.list = Seurat.list, nfeatures = 3000)
  Seurat.list <- PrepSCTIntegration(object.list = Seurat.list, anchor.features = features)
  anchors <- FindIntegrationAnchors(object.list = Seurat.list, normalization.method = "SCT", anchor.features = features)
  Seurat.combined <- IntegrateData(anchorset = anchors, normalization.method = "SCT")
  Seurat.combined <- RunPCA(Seurat.combined, verbose = FALSE)
  Seurat.combined <- RunUMAP(Seurat.combined, reduction = "pca", dims = 1:30)
  Seurat.combined <- FindNeighbors(Seurat.combined, dims = 1:30)
  Seurat.combined <- FindClusters(Seurat.combined, resolution = 0.4, algorithm = 4)

  return(Seurat.combined)
}


Harmony.Integration <- function(Seurat.list)
{

  Seurat.list <- lapply(X = Seurat.list, FUN = function(x) {
  x <- NormalizeData(x)
  x <- CellCycleScoring(x, s.features = s.genes, g2m.features = g2m.genes)
  })
  
  Seurat.combined <- merge(Seurat.list[[1]], Seurat.list[c(-1)])
  Seurat.combined <- FindVariableFeatures(Seurat.combined, selection.method = "vst", nfeatures = 3000)
  Seurat.combined <- ScaleData(Seurat.combined)
  Seurat.combined <- RunPCA(Seurat.combined, verbose = FALSE)
  Seurat.combined <- RunHarmony(Seurat.combined, group.by.vars = "Sample")
  Seurat.combined <- RunUMAP(Seurat.combined, reduction = "harmony", dims = 1:30)
  Seurat.combined <- FindNeighbors(Seurat.combined, reduction = "harmony", dims = 1:30)
  Seurat.combined <- FindClusters(Seurat.combined, resolution = 0.4, algorithm = 4)

  return(Seurat.combined)
}


Liger.Integration <- function(Seurat.list)
{

  Seurat.list <- lapply(X = Seurat.list, FUN = function(x) {
  x <- NormalizeData(x)
  x <- CellCycleScoring(x, s.features = s.genes, g2m.features = g2m.genes)
  })
  
  Seurat.combined <- merge(Seurat.list[[1]], Seurat.list[c(-1)])
  Seurat.combined <- FindVariableFeatures(Seurat.combined, selection.method = "vst", nfeatures = 3000)
  Seurat.combined <- ScaleData(Seurat.combined, split.by = "Sample", do.center = FALSE)
  Seurat.combined <- RunOptimizeALS(Seurat.combined, k = 20, lambda = 5, split.by = "Sample")
  Seurat.combined <- RunQuantileNorm(Seurat.combined, split.by = "Sample")
  # You can optionally perform Louvain clustering (`FindNeighbors` and `FindClusters`) after
  # `RunQuantileNorm` according to your needs
  Seurat.combined <- FindNeighbors(Seurat.combined, reduction = "iNMF", dims = 1:20)
  # Dimensional reduction and plotting
  Seurat.combined <- RunUMAP(Seurat.combined, dims = 1:ncol(Seurat.combined[["iNMF"]]), reduction = "iNMF")
  Seurat.combined <- FindClusters(Seurat.combined, resolution = 0.4, algorithm = 4)
  
  return(Seurat.combined)
}
```
